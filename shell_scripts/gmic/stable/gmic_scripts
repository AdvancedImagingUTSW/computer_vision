
#@gmic
#
#  File        : proudot.gmic
#                ( G'MIC commands file )
#
#  Description : Define a set of gmic commands (mostly useful for bioimage analysis)
#
#  Copyright   : Philippe Roudot (forked from Jerome Boulanger gmic file)
#
#  License     : CeCILL v2.0
#                ( http://www.cecill.info/licences/Licence_CeCILL_V2-en.html )
#
#  This software is governed by the CeCILL  license under French law and
#  abiding by the rules of distribution of free software.  You can  use,
#  modify and/ or redistribute the software under the terms of the CeCILL
#  license as circulated by CEA, CNRS and INRIA at the following URL
#  "http://www.cecill.info".
#
#  As a counterpart to the access to the source code and  rights to copy,
#  modify and redistribute granted by the license, users are provided only
#  with a limited warranty  and the software's author,  the holder of the
#  economic rights,  and the successive licensors  have only  limited
#  liability.
#
#  In this respect, the user's attention is drawn to the risks associated
#  with loading,  using,  modifying and/or developing or reproducing the
#  software by the user in light of its specific status of free software,
#  that may mean  that it is complicated to manipulate,  and  that  also
#  therefore means  that it is reserved for developers  and  experienced
#  professionals having in-depth computer knowledge. Users are therefore
#  encouraged to load and test the software's suitability as regards their
#  requirements in conditions enabling the security of their systems and/or
#  data to be ensured and,  more generally, to use and operate it in the
#  same conditions as regards security.
#
#  The fact that you are presently reading this means that you have had
#  knowledge of the CeCILL license and that you accept its terms.
#


#---------------------------------
#
#@gmic :: Input/Output
#
#---------------------------------


#@gmic tiff3d
#@gmic : Input a 3D tif as a 3D image
#@gmic : Note: This is useful for loading several 3D image stack
tiff3d : -e[^-1] "Load the file $1 as a 3D image"
-v - n=$!
-i $1 -a[{$n}--1] z
-v +

#@gmic toff3d
#@gmic : Output a 3D tif as a 3D image
toff3d : -e[^-1] "Save the 3D image as a tiff file"
-v -
-repeat $!
-o[$>] @{"-filename \"$1\","$>}
-done
-v +

#---------------------------------
#
#@gmic :: 3D Rendering
#
#---------------------------------

#@gmic boundingbox3d : _separation
#@gmic : Bounding box of a 3D volume
#@gmic : $ 100,100,100 -boundingbox3d
boundingbox3d : -skip ${1=10}
-e[^-1] "3D Bounding box"
-repeat $! -l[$>]
-box3d @{0,w},@{0,h},@{0,d} -primitives3d[-1] 1  -opacity3d[-1] .25
-if {$1>0}
  -plane3d @{0,w},@{0,h},$1,{round(@{0,h}/@{0,w}*$1)} -primitives3d[-1] 1 -opacity3d[-1] .1
-endif
-rm[0]
-+3d
-endl -done

#@gmic rendervolume  : _size,_quality,_opacity
#@gmic : Pseudo volumic rendering
#@gmic : $ 100,100,100 -noise 1 -blur 10,0 -max 0 -resize 100%,100%,100%,3,0 -n 0,100 -f 'if(c==0,z*i(x,y,z,0),if(c==1,i(x,y,z,0)*(100-z),0))' -rendervolume
rendervolume: -skip ${1=8},${2=5},${3=.1}
-e[^-1] "Pseudo volumic rendering of image with size $1 quality $2 and opactiy $3"
-v - -repeat $! -l[$>]
-mirror x
-repeat $2 --l[0]
  --threshold2 {($>+1)/($2+1)*(iM-im)+im},{($>+2)/($2+1)*(iM-im)+im+1}
  -*[-2,-1]
  -if {im!=iM} -pointcloud3d -gaussians3d $1,{$3*($<+1)/$2} -else -rm -endif
-endl -done -rm[0] -+3d -md3d -1  -+3d {.5},{.5},{.5}
-endl -done -v +

rendervolume2: -skip ${1=8},${2=5},${3=.1}
-v - -repeat $! -l[$>]
-mirror x
--tones {$2+1} -rm[1,2] -r[1--1] 100%,100%,100%,@{0,s} -*[1--1] [0] -rm[0]
-reverse
-repeat $! i=$< -l[$<]
  -if {im!=iM}
    -pointcloud3d -gaussians3d $1,{$3*($i+1)/$2}
  -else
    -rm
  -endif
-endl -done
-+3d -md3d -1 -+3d {.5},{.5},{.5}
-endl -done -v +

freq3d: -split_details 5 -rm[-1] -isosurface3d 50% -repeat $! -l[$>] -color3d {255/$>},100,{$>*70},{($>+1)*0.1} -endl -done  -add3d  -moded3d 4 -mode3d 4   800,600 -d3d[-2] [-1] 

tone3d: -resize 50%,50%,200%,100%,3  -n 1,256 --tones 5 -*[1--1] [0] -rm[0,1] -pointcloud3d  -gaussians3d[0] 10,0.1 -gaussians3d[1] 10,0.1 -gaussians3d[2] 10,0.2 -gaussians3d[3] 10,0.5 -+3d -md3d 4 800,600 -d3d[-2] [-1]

otsusurface: -- ${--otsu} -rm[-1] -isosurface3d 0

scalesurface: -split_details 3 -rm[-1] -repeat $! -l[$>] -otsusurface -opacity3d {($>+1)*0.2} -endl -done -color3d[-1] 255,0,0 -add3d -moded3d 4 

#@gmic displayvolume : _size,_quality,_opacity
#@gmic : Display the volume with black background, a bounding box and a volumic rendering of the data
#@gmic : $ 100,100,100 -noise 1 -blur 10,0 -max 0 -resize 100%,100%,100%,3,0 -n 0,100 -f 'if(c==0,z*i(x,y,z,0),if(c==1,i(x,y,z,0)*(100-z),0))' -displayvolume 8,5,.1
displayvolume: -skip ${1=8},${2=5},${3=.1}
-e[^-1] "display_volume with size $1 quality $2 and opactiy $3"
-v -
--boundingbox3d 20
-rendervolume2[0] $1,$2,$3
-+3d
-background3d 0,0,0
-v +

#@gmic view3d : _angle1,_angle2
#@gmic : Apply a 3D view
#@gmic : $ 50,50,50,3 -noise 10 -blur 5 -max 0 -n 0,255 -displayvolume 32,5,1 -view3d
view3d : -skip ${1=25},${2=-120}
-e[^-1] "Apply 3D view"
-v - -repeat $! -l[$>]
-rotate3d 0,0,1,$1 -rotate3d 1,0,0,$2
-endl -done -v +

#@gmic colordepth
#@gmic : Color depth coding
#@gmic : $ 100,100,100 -noise 1 -blur 10,0 -max 0 -colordepth 5
colordepth: -skip ${1=5}
-e "colordepth coding with lut $1"
-v - -repeat $! -l[$>]
-_colordepth_volume $1 -s z -+
-endl -done -v +

#@gmic colordepth_volume
_colordepth_volume: -skip ${1=5}
-v - -repeat $! -l[$>]
# make a 3D volume of the same size, color it, resize orignal in color and multiply
-i [0] -f[-1] 'z/(d-1)*255' -map[-1] $1 -resize[0] 100%,100%,100%,3 -*
-endl -done -v +

colordepth_scale: -skip ${1=5}
10,@{0,h-10} -f[-1] '(h-y)/(h-1)*255' -map[-1] $1 -frame[-1] 5,5,0,0,0

#@gmic make_axis: _xmin,_xmax,_ymin,_ymax
#@gmic : Display an axis around an image
#@gmic : $ image.jpg -make_axis 0,1,0,1
make_axis:
-v - -repeat $! -l[$>]
-frame 1,1,0
100%,24,1,3,255 -axes[-1] $1,$2,{-1},{-1}
24,@{0,h},1,3,255 -axes[-1] {w},{w},$4,$3 24,24,1,3,255 -a[-1,-2] y
-a[0,1] y -reverse -a[0,1] x
-frame 12,12,255 100%,5,1,3,255,255,255 -reverse -a y
-endl -done -v +

#@gmic xlabel: _label
#@gmic : Add a label to the x-axis (see make_axis)
#@gmic : $ image.jpg -make_axis 0,1,0,1 -xlabel "hello"
xlabel:
-e[^-1] "Add a x label"
-v - -repeat $! -l[$>]
0 -text[-1] "$1",0,0,18,1,255,255,255 -negative[-1] --lt[-1] 90%
-image[0] [-2],{@{0,w}/2-@{1,w}/2},{@{0,h}-@{1,h}},0,0,1,[-1] -k[0]
-endl -done -v +

#@gmic ylabel: _label
#@gmic : Add a label to the y-axis (see make_axis)
#@gmic : $ image.jpg -make_axis 0,1,0,1 -ylabel "hello"
ylabel:
-e[^-1] "Add a y label"
-v - -repeat $! -l[$>]
0 -text[-1] "$1",0,0,18,1,255,255,255 -negative[-1] -rotate[-1] -90 --lt[-1] 90%   -image[0] [-2],0,{@{0,h}/2-@{1,h/2}},0,0,1,[-1] -k[0]
-endl -done -v +

#@gmic title: _label
#@gmic : Add a title (see make_axis)
#@gmic : $ image.jpg -make_axis 0,1,0,1 -ylabel "hello" -title "title"
title:
-e[^-1] "Add a title"
-v - -repeat $! -l[$>]
0 -text[-1] "$1",0,0,18,1,255,255,255 -negative[-1] --lt[-1] 90%
-image[0] [-2],{@{0,w}/2-@{1,w}/2},0,0,0,1,[-1] -k[0]
-endl -done -v +

mip : -s z -max

orthoMIP : -e "orthoMIP" -v -
-repeat $! -l[$>]
--l[0] s x  max permute zyxc -endl  --l[0] s y max permute xzyc endl -l[0] s z max -endl -montage VH0:1:2,0
-endl -done -v +

orthoMIPn: 
-repeat $! -l[$>]
ff={0,f} fb={0,b} orthoMIP text $ff$fb,5%,5%,23,1,{iM}
-endl -done 

liveMIP:
-w -apply_files $1,"-a z orthoMIPn -n 0,255"



#---------------------------------
#
#@gmic :: Feature detections
#
#---------------------------------

cellMaskOtsu : -b 5 -otsu 256 

cellMaskOtsu2 : -b 10 -otsu 256 -area 0 -threshold {iM}  -not inpaint_holes 10 

fakeNucleusMask : -b 10 -otsu 256 -area 0 -threshold {iM} -distance 1 -threshold {iM-10}

debugMaskFunctionSpy:  -e "debug function $1" 
-repeat $! -l[$>]			 
--$1 --distance[-1] 0 --orthoMIP -adjust_colors[-2] 10,10,50 -normalize [0] -a[-2,-1] x 
-endl -done 

debugMaskFunction:  -e "debug function $1" 
-repeat $! -l[$>]			 
--$1 --distance[-1] 0 -orthoMIP -adjust_colors[0] 10,10,50 -normalize [0] -a x 
-endl -done 

#@gmic quiver2d
#@gmic : Display a sequence 2D vector field on a 2D image sequence
#@gmic : both being represented az a 3D stack
quiver2d:
-e[^-1] "Cumulative sum along z-axis"
-s z -repeat {$!/2} -l[$>,{$>+$!/2}] -quiver[0] [1] -endl -done -rm[{$!/2}--1] -a z

#@gmic zcumsum
#@gmic : Cumulative sum along z-axis
#@gmic : $ 20,20,20 -noise 10 -zcumsum
zcumsum:
-e[^-1] "Cumulative sum along z-axis"
-v - -repeat $! -l[$>]
-s z -repeat {$!-1} -+[{$>+1}] [$>] -done -a z
-v + -endl -done

#@gmic warp2d :
#@gmic : Warp a 2D image stack using a vector field
#@gmic : $ movie.cimg  -a z -resize 50%,50% --l[0] --lucas_kanade 5,1 -zcumsum[-1] -frame 30,30,0 -warp2d -endl -frame[0] 30,30,0 -a x
warp2d:
-s z -repeat {$!/2} -l[$>,{$>+$!/2}] -warp[0] [1],1,1,2 -endl -done -rm[{$!/2}--1] -a z

#@gmic lucas_kanade: _scale
#@gmic : Motion estimation using lucas and kanade approach
#@gmic : Works on 2D+t image stacks/ has side effect
#@gmic : [vx vy] = [Ixx Ixy; Ixy Iyy]^-1 [Ixt Iyt]
#@gmic : $ image.jpg -repeat 20 --shift[-1] 1,0,0,0,2 -done -a z --lucas_kanade 2 -n 0,255 -frame 2 -a x
#@gmic : $ image.jpg -repeat 20 --shift[-1] 1,1,0,0,2 -done -a z --lucas_kanade 2  -s z -repeat {$!/2} -l[$>,{$>+$!/2}] -quiver[0] [1] -endl -done -rm[{$!/2}--1] -a z
lucas_kanade: -skip ${1=2},${2=1}
-e[^-1] "Motion estimation with Lucas et Kanade algorithm"
-v - -repeat $! -l[$>]
-blur_xy $2 -structuretensors 0 -blur_xy $1 # abcdef
--l -s c -rm[0,-1] -*[1,2] -*[0,2] -reverse -- -endl  # dc-be
--l[0] -s c -rm[3,5] -*[0,3] -*[1,2] -- -endl # ae-bc
-l[0] -s c -rm[2,4,5] -*[0,2] -sqr[1] -- -endl # ad-b2
-/[1,2] [0]  -rm[0] -a c
-endl -done -v +

#@gmic estimate_shift
#@gmic : Estimate a translation between two images with sub-pixel accuray
#@gmic : image.jpg  -luminance --shift {?},{?},0,0,2 -estimate_shift
estimate_shift:
-e[^-1] "Translation estimation with Lucas et Kanade algorithm"
-v - -repeat {$!-1} -l[$>,{$>+1}]
-blur_xy 1 --gradient[0] xy,0 --[0,1] --sqr[1,2] --*[1,2] [0] -*[1,2] -rm[0]
Ixy=@{0,ia} Ixx=@{1,ia} Iyy=@{2,ia} Ixt=@{3,ia} Iyt=@{4,ia}
vx={($Iyy*$Ixt-$Ixy*$Iyt)/($Ixx*$Iyy-$Ixy*$Ixy)}
vy={($Ixx*$Iyt-$Ixy*$Ixt)/($Ixx*$Iyy-$Ixy*$Ixy)}
#-echo_stdout $vx,$vy
-rm 1,2 -f $vx,$vy
-endl -done -v +

#@gmic multi_resolution_pyramide : _number_of_scales
#@gmic : Build a multi-resolution pyramid
multi_resolution_pyramide:
-v - -repeat $! -l[$<]
-repeat {$1-1} --resize[-1] 50%,50% -done -reverse
-endl -done -v +

#@gmic estimate_shift_mr
#@gmic : Estimate a translations between two images with sub-pixel accuray
#@gmic : using a multi-resolution scheme
#@gmic : $ image.jpg -luminance --shift 2,3 -crop 5%,5%,95%,95% -estimate_shift_mr 3
estimate_shift_mr: -skip ${1=2}
-multi_resolution_pyramide $1
1,2
-repeat {$1-1}
  --estimate_shift[$>,{$1+$>}] -*[-1,-2] -2 -+[-1,-2]
  @{{$>+1},w},@{{$>+1},h},1,2 -f[-1] 'if(c==0,@{-2,i(0)},@{-2,i(0,1)})'
  -warp[{$1+$>+1}] [-1],1,1,1 -rm[-1] -*[-1] -1
-done
-k[-1]

#@gmic unshift : _iterations
#@gmic : Correct drift along Z in a 3D volume (video stabilization)
#@gmic : Use the linearized optical flow constraint iteratively
#@gmic : $ image.jpg  -luminance -repeat  10 --shift[-1] {2*?},{2*?},0,0,2 -done -a z --unshift 20 -a x
unshift: -skip ${1=10}
-e[^-1] "unshift image stack"
-repeat $! -l[$>]
-repeat $1
-s z -repeat {$!-1} -l[$>,{$>+1}]
--estimate_shift_mr 5 -*[-1] -1 vx=@{2,i(0)} vy=@{2,i(0,1)}
#-echo_stdout $vx,$vy
@{0,w},@{0,h} -f[-1] $vx --f[-1] $vy -a[-1,-2] c
-warp[1] [-1],1,2,1 -rm[-1,-2]
-endl -done -a z
-done
-endl -done

#@gmic register_lucas_kanade : _iterations, _scale
#@gmic : Register images using lucas kanade motion estimation
#@gmic : $ movie.cimg -luminance -resize 50%,50% -a z -register_lucas_kanade 5,10
register_lucas_kanade :  -skip ${1=10},${2=10}
--lucas_kanade $2 -zcumsum[-1] --warp2d
-repeat $1
-lucas_kanade[-1] $2 -zcumsum[-1] -+[-1,-2] --warp2d
-done

#@gmic detect_events : _scale_xy,_scale_t,_threshold
#@gmic : Detect space time events using space time interest points
#@gmic : $ 100,100,100 -noise 1 -blur 2 --detectevents , -pointscoordinates[-1] -resize[0] 100%,100%,100%,3,1 -n[0] 0,255 -circles 5,.5,128,128,32 -k[0]
detectevents : -skip ${1=1},${2=1},${3=9}
-e[^-1] "detect events with scale_xy $1 scale_z $2 and threshold $3"
-v - -repeat $! -l[$>]
-blur_xy $1 -blur_z $2 -structuretensors -blur_xy $1 -blur_z $2
-s z -repeat $! -l[$>] -eigen -k[0] -s c -k[2] -endl -done -a z
thres={@{0,ia}+$3*sqrt(@{0,iv})}
--max_patch[0] 8 -threshold[0] $thres -*
-endl -done -v +

#@gmic detect_spots : _scale,_threshold
#@gmic : Detect spots in the image
#@gmic : $ 100,100 -noise .2,2 -blur 1 -n 0,255 -noise 5 --detect_spots , -pointscoordinates[-1] -resize[0] 100%,100%,1,3,1 -circles 5,.5,128,128,32 -k[0]
detect_spots : -skip ${1=1},${2=4}
-e[^-1] "detect events with scale $1 and threshold $2"
-v - -repeat $! -l[$>]
-blur $1 --blur $1 --
thres={$2*${-mad[0]}}
-d --max_patch[0] 3 --threshold[0] $thres -d  -*
-endl -done -v +

#@gmic local_moments : _scale
#@gmic : Compute local moments tensor
#@gmic : $ 512,512 -circle 50%,50%,25%,1,0xF,255 --local_moments 1
local_moments : -skip ${1=1}
-v - -repeat $! -l[$>]
-norm
-if {d==1}
  --mul[0] 'x'   --mul[0] 'y'   --mul[0] 'x*x'
  --mul[0] 'x*y' --mul[0] 'y*y' -blur $1
  --sqr[1] -/[-1] [0] --[3,-1] -/[3] [0]
  --*[1,2] -/[-1] [0] --[4,-1] -/[4] [0]
  --sqr[2] -/[-1] [0] --[5,-1] -/[5] [0]
  -k[3-5] -a c
-else
  --mul[0] 'x'   --mul[0] 'y'   --mul[0] 'z'   --mul[0] 'x*x'
  --mul[0] 'x*y' --mul[0] 'x*z' --mul[0] 'y*y' --mul[0] 'y*z'
  --mul[0] 'z*z' -blur $1
  --sqr[1] -/[-1] [0] --[4,-1] -/[4] [0]
  --*[1,2] -/[-1] [0] --[5,-1] -/[5] [0]
  --*[1,3] -/[-1] [0] --[6,-1] -/[6] [0]
  --sqr[2] -/[-1] [0] --[7,-1] -/[7] [0]
  --*[2,3] -/[-1] [0] --[8,-1] -/[8] [0]
  --sqr[3] -/[-1] [0] --[9,-1] -/[9] [0]
  -k[4-9] -a c
-endif
-endl -done -v +

#@gmic smooth_moments : _scale,_iterations,_dt
#@gmic : Anisotropic diffusion using local moment tensors
#@gmic : $ image.jpg --noise 10 --smooth_moments[-1] 1,10,1 -print_psnr
smooth_moments: -check "${1=1}>0&${2=100}>0&${3=1}>0"
-v - -repeat $! -l[$>]
  --local_moments[-1] $1 -smooth[0] [1],$2,$3,0 -k[0]
-endl -done -v +

#@gmic pointscoordinates
#@gmic : Return the list of points in the image as 3*N columns vector
#@gmic : $ 100,100 -noise .1,2 --pointscoordinates
pointscoordinates :
-e[^-1] "return the list of points in the image"
-v - -repeat $! -l[$>]
-pointcloud3d -s3d -k[2] -split y,{h/3} -a x
-endl -done -v +

pair_distance:
-repeat $! -l[$>] -s y -a c -endl -done
-repeat @{1,w}
--l[0,1]
-shift[1] $>,0,0,0,2
-- -norm
-endl
-done
-rm[0,1]
-a y
-s x -repeat $! -shift[$>] 0,$>,0,0,2 -done -a x

#@gmic circles : _size,_opacity,_color
#@gmic : plot circles on image [0] at coordinates given by image [1]
#@gmic : $ 256,256 -noise .1,2 --pointscoordinates --circles 5 -rm[-1]
#@gmic : $ image.jpg --l[0] -blur 3 -structuretensors -blur 3 -eigen -k[0] -channels 1 --gt {9*@{-mad}} --max_patch[0] 8 -* -pointscoordinates -endl -circles 5 -rm[-1]
circles : -skip ${1=10},${2=1},${3=255},${4=255},${5=255}
-e[^-1] "draw @{1,w} circles on image [0]"
-v -
-repeat {@{1,w}}
  -if {@{0,d}>1}
    x={@{1,i($>,0)}} y={@{1,i($>,1)}} z={@{1,i($>,2)}}
    -repeat @{0,s} -sh[0] $z,$z,$> -ellipse[-1] $x,$y,$1,$1,0,$2,0xFFFFFF,$3 -rm[-1] -done
   -else
    x=@{1,i($>,0)} y=@{1,i($>,1)}
    -ellipse[0] $x,$y,$1,$1,0,$2,0xFFFFFF,$3,$4,$5
  -endif
-done

#@gmic addtext : _size,_color,_opacity
#@gmic : Add labels on image [0] at coordinates given by image [1]
#@gmic : $ 256,256 -noise .1,2 --pointscoordinates -addtext 5 -rm[-1]
addtext : -skip ${1=21},${2=128},${3=1}
-e[^-1] "add text labels from @{1,w} points"
-v -
-repeat {@{1,w}}
  -if {@{0,d}>1}
    x={@{1,i($>,0)}} y={@{1,i($>,1)}} z={@{1,i($>,2)}} id={$>+1}
    -repeat @{0,s} -sh[0] $z,$z,$> -text[-1] $id,$x,$y,21,$3,$2,$2,$2 -rm[-1] -done
  -else
    x=@{1,i($>,0)} y=@{1,i($>,1)} id={$>+1}
    -text[0] $id,$x,$y,21,$3,$2,$2,$2
  -endif
-done

#@gmic croparound : _size_xy,_size_z
#@gmic : Crop image [0] around coordinates given by image [1]
#@gmic : $ image.jpg 100%,100% -f[-1] 0 -noise[-1] .1,2 --pointscoordinates[-1] --croparound[0,-1] 5 -append_tiles[3--1] ,  -rm[-2] -dilate[1] 5 -*[1] 128 -blend[0,1] add
croparound :  -skip ${1=10},${2=10}
-e[^-1] "crop image [0] around "@{1,w}" coordinates given by image [1]"
-v -
-repeat {@{1,w}}
  -if {@{0,d}>1}
    x=@{1,i($>,0)} y=@{1,i($>,1)} z=@{1,i($>,2)}
    --crop[0] {$x-$1},{$y-$1},{$z-$2},{$x+$1},{$y+$1},{$z+$2}
  -else
    x=@{1,i($>,0)} y=@{1,i($>,1)}
    --crop[0] {$x-$1},{$y-$1},{$x+$1},{$y+$1}
  -endif
-done -rm[0,1] -v +

#@gmic random_walks : width,height,length,number,speed
#@gmic : Generate random walks tracks (list of coordinates x,y,t as a Nx3 image.)
#@gmic : $ 100,100,20  -random_walks 100,100,20,5,1 -circles 1 -k[0] -blur_xy 1 -s z -max
#@gmic : $ 100,100,20  -random_walks 100,100,20,10,1 -circles 1 -k[0] -blur 1 -n 0,255 -displayvolume 8,10,1 -rotate3d 0,0,1,25 -rotate3d 1,0,0,-120 -snapshot3d 600,1,0,0,0 -autocrop
random_walks :
number=$4 width=$1 height=$2 length=$3 speed=$5
$number,3
-l[-1]
  -noise 1,1
  -sh 0,0,0,0 -n[-1] 1,{$width-1} -rm[-1]
  -sh 1,1,0,0 -n[-1] 1,{$height-1} -rm[-1]
  -sh 2,2,0,0 -f[-1] 0 -rm[-1]
  -repeat {$length-1} --l[-1]
    -noise 1
    -sh 0,0,0,0 -c[-1] 1,{$width-2} -rm[-1]
    -sh 1,1,0,0 -c[-1] 1,{$height-2} -rm[-1]
    -sh 2,2,0,0 -f[-1] '$>+1' -rm[-1]
  -endl -done -a x
-endl

#---------------------------------
#
#@gmic :: Filtering and deconvolution
#
#---------------------------------

#@gmic movavg : _size>=1
#@gmic : moving average of image list with a box filter of size _size
#@gmic : $ 11 -f 'x>w/2' --l[-1] -s x -movavg 9 -a x -endl  --blur[0] 1.2 -a c -display_graph
movavg : -check "$1>=1"
-e[^-1] "moving average with size "$1 -v -
n={$1-1}
-repeat $n
  -repeat {{$!}-1} --+[{$>},{$>+1}] -*[-1] .5 -rm[$>] -mv[-1] $> -done
  -reverse
-done
-if {$n%2!=0} -reverse -endif
-v +

#@gmic zmean
#@gmic : average along z-axis
zmean :
-v - -repeat $! -l[$>]
n=@{0,d} -s z -+ -/ $n
-endl -done -v +

#@gmic zstd
#@gmic : standard deviation along z-axis
zstd :
-v - -repeat $! -l[$>]
--zmean -sqr[-1]
-l[0] -sqr -zmean -endl
-- -sqrt
-endl -done -v +

#@gmic zmax
#@gmic : maximum along z-axis
zmax :
-v - -repeat $! -l[$>]
-s z -max
-endl -done -v +

#@gmic kymoline:
#@gmic : interactively select a line and extract a line profile
kymoline:
--select 1
x1=@{-1,i(0,0)} y1=@{-1,i(0,1)} x2=@{-1,i(0,3)} y2=@{-1,i(0,4)}
d={sqrt(($x2-$x1)^2+($y2-$y1)^2)}
u={($x2-$x1)/$d} v={($y2-$y1)/$d}
-rm[-1]
-f 'if(x<=$d&&y==0,i($x1+x*$u,$y1+x*$v,z,c,1),5)'
-crop 0,0,{int($d-1)},0

#@gmic fftshift
#@gmic : Shift a image so that the fft has it center in the middle
#@gmic : $ image.jpg -fftshift
fftshift :
-v - -repeat $! -l[$>]
-shift {-int(w/2)},{-int(h/2)},{-int(d/2)},0,2
-endl -done -v +

#@gmic whiten_frequency : _alpha
#@gmic : Whitening filter (equalize the frequency of the image; nothing todo with color)
#@gmic : $ image.jpg -whiten_frequency
whiten_frequency : -check "${1=.25}>=0"
-e[^-1] "Whiten the frequency with parameter "$1
-v - -repeat $! -l[$>]
#E=@{0,sqrt(iv)}
-fft --a c -norm[-1] -pow[-1] $1 -max[-1] 1e-12 -/[-1] {ia} -/[0-1] [2] -rm[2] -ifft -k[0]
#-* {$E/sqrt(iv)}
-endl -done -v +

#@gmic deblur_goldmeinel2 : sigma>=0, _nb_iter>=0, _acceleration>=0, _kernel_type={ 0=quasi-gaussian (faster) | 1=gaussian }.
#@gmic : Deblur and zoom selected images using Gold-Meinel algorithm
#@gmic : Default values: 'nb_iter=8', 'acceleration=1' and 'kernel_type=1'.
#@gmic : $ image.jpg --blur 1 --deblur_goldmeinel[-1] 1
###### : (contribution from Jérôme Boulanger).
deblur_goldmeinel2 : -check "$1>=0 && ${2=8}>=0 && ${3=1}>=0" -skip ${4=1} -skip ${5=1}
  -e[^-1] "Deblur image$? using Gold-Meinel algorithm, with sigma $1, $2 iterations, acceleration $3 and "@{-arg\ 1+!$4,"",quasi-}"gaussian kernel."
  -v - -repeat $! -l[$>]
    [0] -r[-1] 200%,200%,200%,100%,5 -repeat $2
      --b[-1] $1,1,$4 -r[-1] 50%,50%,50% --/[0,-1] -rm[-2] -^[-1] $3 -r[-1] 200%,200%,200%,100%,5 -*[-1,-2] # u *= f / Hu

    -done -rm[0]
  -endl -done -v +

#@gmic deblur_richardsonlucy2 : sigma>=0, nb_iter>=0, _kernel_type={ 0=quasi-gaussian (faster) | 1=gaussian }.
#@gmic : Deblur and zoom selected images using Richardson-Lucy algorithm.
#@gmic : Default values: 'nb_iter=50' and 'kernel_type=1'.
#@gmic : $ image.jpg --blur 1 --deblur_richardsonlucy[-1] 1
###### : (contribution from Jérôme Boulanger).
deblur_richardsonlucy2 : -check "$1>=0 && ${2=50}>=0" -skip ${3=1} -skip ${4=1}
  -e[^-1] "Deblur image$? using Richardson-Lucy algorithm, with sigma $1, $2 iterations and "@{-arg\ 1+!$3,"",quasi-}"gaussian kernel."
    -v - -repeat $! -l[$>]
    [0] -r[-1] 200%,200%,200%,100%,5 -repeat $2
    --b[-1] $1,1,{$3!=0} -r[-1] 50%,50%,50%,100%,5 --/[0,-1] -rm[-2] -r[-1] 200%,200%,200%,100%,5 -b[-1] $1,1,{$3!=0}  -*[-1,-2] # u *= H ( f / Hu )
    -done -rm[0]
  -endl -done -v +

#@gmic correlate_fft
#@gmic : Convolve selected images two-by-two through fourier transforms.
#@gmic : $ image.jpg 100%,100% -gaussian[-1] 20,1,45 --convolve_fft
correlate_fft :
  -e[^-1] "Correlate image$? two-by-two through fourier transforms."
  -v - -repeat {int($!/2)} -l[$>,{$>+1}]
    w2={int(@{0,w}/2)} h2={int(@{0,h}/2)} d2={int(@{0,d}/2)}
    -r[1] [0],[0],[0],1,0,0,0.5,0.5,0.5,0.5 -shift[1] -$w2,-$h2,-$d2,0,2
    -fft[0] -fft[2] -*[1] -1
    --*[-4] [-1] --*[-4] [-3] -+[-2,-1]
    -*[-5,-3] -*[-3,-2] --[-3,-2]
    -ifft -rm[-1]
  -endl -done -v +

#@gmic deconvolve_richardsonlucy : nb_iter>=0,
#@gmic : deconvolve images using the first one as a blur operator (PSF)
#@gmic : $ image.jpg 100%,100% -gaussian[-1] 3,1,45 -normalize_sum[-1] --convolve_fft --deconvolve_richardsonlucy[1,2] 10 -print_psnr[0,2,3]
deconvolve_richardsonlucy : -check "${1=5}>=1"
 -e[^-1] "Deblur image$? using Richardson-Lucy algorithm with a custom filter."
 -v -
 -repeat {$!-1} -l[0,{$>+1}]
 -r[0] @{1,w},@{1,h},@{1,d},100%,0,0,.5,.5,.5 -normalize_sum[0]
 [1] -repeat $1
 --convolve_fft[0,-1] --/[1,-1] -rm[-2] --correlate_fft[0,-1] -rm[-2] -*[-1,-2]
 -done -rm[0,1]
 -endl -done -v +

#@gmic deconvolve_goldmeinel :  _nb_iter>=0, _acceleration>=0
#@gmic : Deblur and zoom selected images using Gold-Meinel algorithm
#@gmic : Default values: 'nb_iter=8', 'acceleration=1' and 'kernel_type=1'.
#@gmic : $ image.jpg 100%,100% -gaussian[-1] 5,1,45 -normalize_sum[-1] --convolve_fft --deconvolve_goldmeinel[1,2] 5 -print_psnr[0,2,3]
deconvolve_goldmeinel : -check "${1=5}>=1&&${2=1}>=1"
  -e[^-1] "Deblur image$? using Gold-Meinel algorithm, with $1 iterations, acceleration $2."
  -v - -repeat {$!-1} -l[0,{$>+1}]
    -r[0] @{1,w},@{1,h},@{1,d},100%,0,0,.5,.5,.5 -normalize_sum[0]
    [1] -repeat $2
     --convolve_fft[0,-1]  --/[1,-1] -rm[-2] -^[-1] $2 -*[-1,-2] # u *= (f / Hu)^$3
    -done -rm[0,1]
  -endl -done -v +

#@gmic normalize_sum
#@gmic : Normalize the image so that the sum of the values is 1
#@gmic : $ image.jpg --normalize_sum
normalize_sum :
-e[^-1] "Normalize the image so that its sum is equal to 1."
-v - -repeat $! -l[$>]
 -* {1/(ia*w*h*d*s)}
-endl -done -v +

#@gmic local_variance : _radius
#@gmic : Local variance filter
#@gmic : $ image.jpg  --local_variance
local_variance: -skip ${1=2}
-e[^-1] "Local Variance filter with scale "$1
-v - -repeat $! -l[$>]
 --blur $1,1,1 -- -sqr -blur $1,1,1
-endl -done -v +

#@gmic normalize_local_variance : _amplitude,_radius,_threshold,_repeat
#@gmic : Local variance normalization
#@gmic : $ image.jpg  --normalize_local_variance
normalize_local_variance: -skip ${1=50},${2=2},${3=25},${4=1}
  -e[^-1] "Normalize local variance with amplitude $1, scale $2, threshold $3 (x$4 times)."
  -v -
  -repeat $4
   --local_variance $2 -sqrt[-1] -max[-1] $3 # compute local standard deviation
   --blur[0] $2,1,1 ---[0,-1] -/[-1] [1] -*[-1] $1 -+[-2,-1] -k[-1] # x = <x> + alpha * (x-<x>)/<x'x>
  -done -v +

#@gmic local_wiener : _radius
#@gmic : Local Wiener filtering
#@gmic : X = <X> + ((<X-<X>>)'(<X-<X>>) - <N'N>)/(<X-<X>>)'(<X-<X>>) (X-<X>)
#@gmic : $ image.jpg --noise 10 --local_wiener[-1] 1 -print_psnr
local_wiener : -skip ${1=2}
-e[^-1] "Local Wiener filtering"
-v - -repeat $! -l[$>]
sigma=@{-noise_std}
--blur $1 # mean
--local_variance[0] {2*$1} ---[-1] {$sigma*$sigma} -reverse[-1,-2] -/[-1,-2] # variance
---[0,1] # img-mean
-*[-1,-2] -+[-1,-2] -k[-1]
-endl -done -v +

#@gmic periodize
#@gmic : Periodization of the image
#@gmic : $ image.jpg -periodize
periodize :
-e[^-1] "periodize"
-v - -repeat $! -l[$>]
-if {w>1} --mirror x -a x -endif
-if {h>1} --mirror y -a y -endif
-if {d>1} --mirror z -a z -endif
-endl -done -v +

#@gmic tape
#@gmic : apply a Hann window
#@gmic : $ image.jpg -tape
tape :
-e[^-1] "apply a Hann tapering window"
-v - -repeat $! -l[$>]
   -if {w>1} -f 'i*sin(pi*x/(w-1))^2' -endif
   -if {h>1} -f 'i*sin(pi*y/(h-1))^2' -endif
   -if {d>1} -f 'i*sin(pi*z/(d-1))^2' -endif
-endl -done -v +

#@gmic powerspectrum :
#@gmic : Compute power spectrum
#@gmic : $ image.jpg -powerspectrum
powerspectrum :
-e[^-1] "Compute power spectrum"
-v - -repeat $! -l[$>]
-display_fft -k[0]
-endl -done -v +

#@gmic fouriermix : _cut_of_frequency
#@gmic :  Mix two images using their respectives low and high frequencies
#@gmic : $ image1.jpg image2.jpg  --fouriermix .5
fouriermix : -skip ${1=50%}
-e[^-1] "fourier mix images."
-fft[0] -fft[2] -fftshift
# make a mask
100%,100% -circle[-1] 50%,50%,$1,1,1 -blur[-1] 1,1,1 -n[-1] 0,1 -d
-*[0,1] [-1] -negative[-1] -*[2,3] [-1] -rm[-1] -+[0,2] -+[1,2] -fftshift
-ifft  -k[0]

#@gmic fouriercut : _threshold
#@gmic : Illustrate the thresholding of Fourier coefficients
#@gmic : $ image.jpg --noise 10 --fouriercut[-1] 1 -print_psnr
fouriercut : -skip ${1=1}
-e[^-1] "Threshold Fourier coefficients with threshold "$1"."
-v - -repeat $! -l[$>]
--l[-1] -powerspectrum -threshold $1 -fftshift -endl
-fft[0] -*[0] [-1] -*[1] [-1] -rm[-1] -ifft -k[0]
-endl -done -v +

#@gmic unstrip : _smoothness,_scale,_threshold
#@gmic : Remove stripes in an image
#@gmic : $ image.jpg -f '.5*i*(1+.25*sin(x))' --unstrip
unstrip : -skip ${1=25},${2=20},${3=4}
-e[^-1] "Remove stripes"
-v - -repeat $! -l[$>]
# create a mask
   --l[-1]
     -tape -powerspectrum -norm -detect_spots 1,$3 -dilate_circ $2 -gt 0
     -n 0,1 -negative -circle 50%,50%,$2,1,1
     -if {@{-1,im}<.9} # check if some spots have been detected
       active=1 -blur $1 -n 0,1 -fftshift -if {iM==0} -f 1 -endif
     -else
       active=0
     -endif
   -endl
   #apply the mask
   -if {$active==1}
    -fft[0] -*[0] [-1] -*[1] [-1] -rm[-1] -ifft
   -endif
   -k[0]
-endl -done -v +

#@gmic autocorrelate
#@gmic : Autocorrelation using fourier transform
#@gmic : $ image.jpg -autocorrelate
autocorrelate :
-e[^-1] "Compute autocorrelation"
-v - -repeat $! -l[$>]
-fft -sqr -+ -sqrt -ifft -k[0] -fftshift
-endl -done -v +

#@gmic psf : _NA,_n,_wavelength,_pixel_size
#@gmic : Generate a rough approximation of a microscope PSF
#@gmic : $ 64,64,32 -psf , -+ 1 -log
psf : -skip ${1=1.40},${2=1.33},${3=488},${4=160},${5=200}
C={2*pi/$3*$1/$2*50}
-v - -repeat $! -l[$>]
-f 'dx=x-w/2;dy=y-h/2;dz=z-d/2;if($C*sqrt(dx*dx+dy*dy)<(d-abs(dz)),1,0)'
-blur 1
-s z -repeat $! -l[$>] -fftpolar -k[0] -endl -done -a z
-sqr
-endl -done -v +

#@gmic beads2psf :
#@gmic : Compute an approximate PSF from an image bead using autocorrelation method
beads2psf : -skip ${1=5}
-e[^-1] "Compute a PSF from an image bead using autocorrelation method"
-v - -repeat $! -l[$>]
-tape -autocorrelate -- {sqrt(@{0,iv})} -threshold 0,1
-f 'dx=x-w/2;dy=y-h/2;dz=z-d/2;sigma=9+$1*dz*dz;i*exp(-.5*(dx*dx+dy*dy)/(sigma))/sqrt(2*pi*sigma)'
-sqr -* {1/(ia*w*h*d*s)}
-endl -done -v +

#@gmic simmod:
#@gmic : Analyse SIM modulation by dividing by the sum of the images
simmod :
--+ -*[-1] {1/($!-1)} -/[0--2] [-1] -rm[-1]

#@gmic spotify : _scale>0,_nb_iter>0,
#@gmic : Make everything look like a spot
#@gmic : Default values '_nb_iter=1, _scale=1'
#@gmic : $ image.jpg --spotify 1,10
#@gmic : $ image.jpg --spotify 1,20 -norm[-1] -gt[-1] 5% -blur 1 -*
spotify : -check "${1=1}>0 && ${2=1}>0"
-e[^-1] "Spotify with scale $1 with $2 iterations"
-v - -repeat $! -l[$>]
s=@{0,a} -repeat $2 -blur $1 --blur {2*$1} -- -cut 0,100% -f 'i*{$s}/ia' -done
-endl -done -v +

#@gmic depthmap
#@gmic : Compute a depth map from the gradients norm
#@gmic : $ image.jpg -depthmap
depthmap:
-e[^-1] "Depth map"
-v - -repeat $! -l[$>]
  --blur 2 -gradient_norm -reverse -/ -f '1/sqrt(i*i)-1'
 -fft 100%,100%,1,1,'-(4-2*cos(2*x*pi/w)-2*cos(2*y*pi/h))'
  -=[-1] 1 -/[-3,-2] [-1] -rm[-1] -ifft -k[0] -n 0,1
-endl -done -v +

#@gmic mapblur : _levels
#@gmic : Blur the image with a map
#@gmic : $ image.jpg --f '10*x/w' -mapblur
mapblur: -check "${1=10}>0"
-e[^-1] "Blur images using a blur map (works using pairs of images)."
-v - -repeat {$!/2} -l[{2*$>},{2*$>+1}]
  smin=@{1,im} smax=@{1,iM}
  -l[0] -repeat $1 --blur[0] {$smin+$>*($smax-$smin)/($1)} -done -rm[0] -a z -endl
  -l[1] -tones $1 -gt 0 -blur 1 -a z -endl
  -* -s z -+
-endl -done -v +

#@gmic tubeness : _scale>0
#@gmic : Tubeness filter based on the eigen value of the Hessian
#@gmic : Default values '_scale=1'
#@gmic : $ image.jpg --tubeness 3
#@gmic : $ image.jpg --tubeness 1 -n 0,255 -blend add
tubeness : -check "${1=1}>0"
-e[^-1] "Tubeness with scale $1."
-v - -repeat $! -l[$>]
  -blur $1
  -s c -repeat $! -l[$>]
    -hessian -a c -eigen -k[0] -s c -k[1] -* -1 -cut 0,100%
  -endl -done -a c
-endl -done -v +


firstEigen: -eigen -k[0]

#@gmic tubenessp : _scale>0
#@gmic : Tubeness filter based on the eigen value of the Hessian
#@gmic : Default values '_scale=1'
#@gmic : $ image.jpg --tubeness 3
#@gmic : $ image.jpg --tubeness 1 -n 0,255 -blend add
tubenessp : -check "${1=1}>0"
-e[^-1] "Tubeness with scale $1."
-v - -repeat $! -l[$>]
  -blur $1
  -s c -repeat $! -l[$>]
    -hessian -a c -apply_parallel_overlap "firstEigen",1 -s c -k[1] -* -1 
  -endl -done -a c
-endl -done -v +

#@gmic bgsubstract : _length>0
#@gmic : Substract the background using a temporal top-hat filter
bgsubstract:  -check "${1=5}>0"
 -e[^-1] "Temporal background substraction with length $1."
 -v - -repeat $! -l[$>]
   1,1,$1 -f[-1] 1 --erode[0] [1] --[0] [-1] -rm[1,-1]
 -endl -done -v +

#@gmic schizo : _amplitude,_amplitude_normal,_nb_iterations,_strength
#@gmic : Schizo filter gives either a furry image or a smoothed image
#@gmic : Default values '_amplitude=100,amplitude_normal=-50 _nb_iter=5,_strength=.75'
#@gmic : $ image.jpg --schizo 100,-50 --schizo[0] -50,100 -max 0
schizo : -skip ${1=100},${2=-50},${3=5},${4=.75}
-e[^-1] "Schizo filter smoothing with // $1 and T $2 and $3 iterations."
-v - -repeat $! -l[$>]
[0]
-repeat $3
 -l[-1]
   --iee -*[-1] {$1/(0.0001+max(abs(@{-1,m}),abs(@{-1,M})))}
   --inn[0] -*[-1] {$2/(0.0001+max(abs(@{-1,m}),abs(@{-1,M})))}
   -+
 -endl
 -*[-1] $4  --*[0] {1-$4} -+[-1,-2]
-done -rm[0]
-endl -done -v +

#@gmic scandoc : _smooth,_background,_black,_white
#@gmic : improve scanned document
#@gmic : $ image.jpg -scandoc
scandoc: -skip ${1=3},${2=100},${3=10%},${4=90%}
-v - -repeat $! -l[$>] -split_opacity -l[0]
-median $1 --blur $2 -- -min 0
-s c -n 0,1 -a c -c $3,$4 -n 0,255
-endl -a c -endl -done -v +

#@gmic oblur: _nb_scales,_nb_angles
#@gmic : Oriented blurs
oblur: -skip ${1=1},${2=6}
-v - -repeat $! -l[$>]
  -repeat $1 s={2^($>+2)} -repeat $2 a={$>/$!*180}
  -echo_stdout $s", "$a
  #--blur_linear[0] $s,.1,$a
  --l[0] -blur_linear $s,1,$a  --blur 1 -- -endl
  -if {$!==3}  -max[1,2] -endif
  -done -done
  -rm[0]
-endl -done -v +

#@gmic oheat: _nb_scales,_nb_angles
#@gmic : Oriented blurs
oheat: -skip ${1=1},${2=6}
-v - -repeat $! -l[$>]
  -repeat $1  -repeat $2 a={$>/$!*180}
    --l[0] -blur_linear 2,.5,$a  --blur 1 -- -endl
    -done
    -max[1--1] -+
    -done
-endl -done -v +

#@gmic warp_affine
#@gmic : Warp the image [0] using an affine field defined by a 3x3 matrix [1]
#@gmic : $ image.jpg 3 -f[-1] 1 -diagonal[-1] -noise[-1] .1  --warp_affine -k[0,-1]
warp_affine :
--l[0,1]
 params=(@{1,i(0,0)},@{1,i(1,0)},@{1,i(2,0)};\
         @{1,i(0,1)},@{1,i(1,1)},@{1,i(2,1)};\
         @{1,i(0,2)},@{1,i(1,2)},@{1,i(2,2)})
 @{0,w},@{0,h},1,1,1 --f[-1] x --f[-1] y -a[-3--1] c
 -mix_channels[-1] $params
 -channels[-1] 1,2
 -warp[0] [-1],0,2,0 -rm[-1,-2]
-endl
-rm[0,1]

#@gmic midway
#@gmic : Midway equalization of two channels
#@gmic : $ image.jpg -channels 0,1 -s c -*[-1] 2 -a c --midway
midway :
-repeat $! -l[$>]
--l[0]
  -resize 20%,20%
  -s c -unroll y -l[0] 1,@{0,h},1,1,1 -a x -endl  -transpose[0]
  -l[0] -svd -f[-2] 'if(i>1e-6,1/i,0)' -diagonal[-2] -transpose[-1] -mmul -endl -mmul
  a=@{0,0} b=@{0,1} -rm[-1]
-endl
-s c
-+[-1] {$b} -*[-1] {1/$a} -a c
-endl -done

midway2:
 --l[0] -s c -y y 1,@{0,h},1,1,1 -a x -svd -k[-1] -endl
 params=(@{1,i(0,0)},@{1,i(1,0)},@{1,i(2,0)};\
         @{1,i(0,1)},@{1,i(1,1)},@{1,i(2,1)};\
         @{1,i(0,2)},@{1,i(1,2)},@{1,i(2,2)})
 -rm[1]
 -echo_stdout $params
 -mix_channels[0] $params  -n 0,255

#@gmic vobs : _scale
#@gmic : Motion quantity (Normal motion)  $ h * (|Ixy|^2 |It|/|Ixy|) / h * Ixy^2$
#@gmic : Irani, Michal and Rousso, Benny and Peleg, Shmuel, Detecting and tracking multiple moving objects using temporal integration, ECCV'92, \href{http://dx.doi.org/10.1007/3-540-55426-2_33}{pdf}.
#@gmic : $ 100,100,10 -noise 1 -blur 1 --vobs
vobs : -check "${1=1}>0 && ${2=3}>0"
-e[^-1] "Motion quantity with scale $1"
-v - -repeat $! -l[$>]
-gradient -a[0,1] c -norm[0] -abs[1] -*[1] [0] -sqr[0] -blur $1,1,1 -reverse -max[1] 5% -/
-endl -done -v +

#@gmic display_vobs
#@gmic : Display local diffusion coefficient
#@gmic : $ 200,100 -noise .7,2 -blur 2,1,1 -repeat 20 --l[-1] --laplacian -*[-1] .05 -+ -endl -done  -a z -display_vobs
display_vobs :
--vobs 1 A={round(@{-1,im},0.001)} B={round(@{-1,iM},0.001)} -*[-1] '{128/max(im,iM)}' -+[-1] 128  -map[-1] 5
-resize[0] 100%,100%,100%,3,1 -apply_gamma[0] 1.5 -n[0] 0,255
-l[0] -s z -frame 5,12,64 -shift 0,5,0,0,2 -text "Original sequence",5,0,13,1,255 -a z -endl
-l[1] -s z -repeat $! -l[$>] 1,100% -f[-1] 'h-y' -n 0,255  -map[-1] 5 -resize[-1] 5,@{0,h},1,3,5 -frame[-1] 3,0,64  -resize[-1] 100%,@{0,h},1,3,5 -a x
-frame 5,12,64 -shift 0,5,0,0,2
-text "Vobs ["$A":"$B"]",5,0,13,1,255 -endl -done -a z -endl
-a x

display_pseudocolor :
 A={round(@{-1,im},0.0001)} B={round(@{-1,iM},0.0001)} -n[-1] 0,255 -map[-1] 5
 -rectangle {w-50-5},{h/4-5},{w-5},{h-h/4+5},.5,0,0,0
 -add_colorbar[-1] {w-50},{h/4},{w-40},{h-h/4},$A,$B,6,255

#@gmic display_colordepth : _dz
display_colordepth :
-e[^-1] "display the 3D image with a depth color coded."
-v - -repeat $! -l[$>]
 H={d*$1} -colordepth , -a z -min {ia+10*sqrt(iv)} -n 0,255 -s z
 -rectangle {w-50-5},{h/4-5},{w-5},{h-h/4+5},.5,0,0,0
 -add_colorbar[-1] {w-50},{h/4},{w-40},{h-h/4},0,$H,6,255
-endl -done -v +

#@gmic add_colorbar : x0,y0,x1,y1,_min,_max,_ntics,color,colormap
#@gmic : Add a colorbar to the image
#@gmic : $ image.jpg -luminance -map 5 -add_colorbar {w-40},20,{w-30},{h-20},0,255,6,255,5
add_colorbar :
-skip ${5=0},${6=255},${7=6},${8=255},${9=""},${10=5}
-repeat $! -l[$>]
{$3-$1},{$4-$2} -l[-1] -f 'h-y' -n 0,255 -map $10 -endl
-frame[1] 1,1,$8 -image[0] [1],$1,$2,0,0,1 -k[0]
-repeat $7
  val={round($5+$>/($7-1)*($6-$5),.001)}
  -text "- "$val" "$9,{$3+1},{$4-$>*($4-$2-5)/($7-1)-10},13,1,$8
-done
-endl -done

#@gmic local_diffusion_coefficient : _scale,_threshold
#@gmic : Estimate local diffusion coefficient It - D (Ixx+Iyy)=0 using D=It/(Ixx+Iyy)
#@gmic : $ 100,100 -noise .7,2 -blur 2,1,1 -repeat 20 --l[-1] --laplacian -*[-1] .05 -+ -endl -done  -a z -local_diffusion_coefficient 2,.5
local_diffusion_coefficient : -check "${1=2}>0 && ${2=.5}>=0"
-e[^-1] "Local diffusion coefficient estimation using scale $1 and threshold $2"
-v - -repeat $! -l[$>]
   --l[0] -s z -laplacian -a z -endl           # Ixx+Iyy
   --l[0] -s z -gradient_norm -a z -sqr -endl  # ||Ix+Iy||^2
   -gradient[0] z,1                            # It
   -l[0,1] # try to compute It/Ixx+Iyy as stably as possible
     R={@{1,ia}+$2*sqrt(@{1,v})}
     -a c -f 'b=i(x,y,z,0);a=i(x,y,z,1);if(abs(a)>abs(b),b/a,if(abs(b)>$R,1/(b/a),0))'
     -channels 0
   -endl
   -*[0] [1] -blur $1,1,1 -max[1] {@{1,ia}+$2*sqrt(@{1,v})}  -/
   -channels 0
-v + -endl -done

ldc :
-local_diffusion_coefficient $*

#@gmic display_ldc :
#@gmic : Display local diffusion coefficient
#@gmic : $ 200,100 -noise .7,2 -blur 2,1,1 -repeat 20 --l[-1] --laplacian -*[-1] .05 -+ -endl -done  -a z -display_ldc
display_ldc :
--ldc 2,3 A={round(@{-1,im},0.001)} B={round(@{-1,iM},0.001)} -*[-1] '{128/max(im,iM)}' -+[-1] 128  -map[-1] 5
-resize[0] 100%,100%,100%,3,1 -apply_gamma[0] 1.5 -n[0] 0,255
-l[0] -s z -frame 5,12,64 -shift 0,5,0,0,2 -text "Original sequence",5,0,13,1,255 -a z -endl
-l[1] -s z -repeat $! -l[$>] 1,100% -f[-1] 'h-y' -n 0,255  -map[-1] 5 -resize[-1] 5,@{0,h},1,3,5 -frame[-1] 3,0,64  -resize[-1] 100%,@{0,h},1,3,5 -a x
-frame 5,12,64 -shift 0,5,0,0,2
-text "Local diffusion coefficient ["$A":"$B"]",5,0,13,1,255 -endl -done -a z -endl
-a x

#@gmic print_psnr : _max_value
#@gmic : Display the psnr on the image list taking the first one as a reference
#@gmic : $ image.jpg --noise 20 --blur[-1] 1 -print_psnr
print_psnr : -skip ${1=255}
-e[^-1] "Compute PSNR with image 0 and print it on the other images."
-v - --psnr $1
-repeat {$!-2} -text_outline[{$>+1}] "PSNR:"{round(@{-1,i(0,$>+1)},.01)}"dB",5,5,30,1 -done
-rm[-1] -v +

#@gmic noise_std
#@gmic : Estimate the noise variance
#@gmic : $ image.jpg -noise 10 sigma={round(@{-noise_std},.1)} -text_outline "Noise std:"$sigma,5,5,30,1
noise_std :
-e[^-1] "Compute noise variance."
-v - --laplacian -if {@{0,d}==1}  -u {@{-mad[-1]}/sqrt(20.0)} -else -u {@{-mad[-1]}/sqrt(42.0)} -endif -rm[-1]
-v +

#@gmic pca
#@gmic : Principal component analysis
#@gmic : $ image2.jpg --l -split_tiles 64,64 -y y -a x -pca -k[-1] -s x -r 8,8,1,1,-1 -n 0,255 -frame 1,1,255 -append_tiles , -r[-1] 400%,400% -frame 0,20 -title dictionary -endl
pca :
-e[^-1] "Principal component analysis"
-v - -repeat $! -l[$>]
  n=@{-1,w} -- 'ia' --transpose[-1] -**[-2,-1] -/ $n -eigen
-endl -done -v +

spca: -skip ${2=20}
-v - -repeat $! -l[$>]
  -repeat $2
    p={sqrt(h)}
    --l --pca -k[0,-1]  -reverse -transpose[0] --** -threshold[-1] $1,1 -rm[1] -transpose[0] -** -endl
    -*[0] .25 -*[1] .75 -+
  -done
  -pca
-endl -done -v +


#@gmic kpca : _components,_iterations
#@gmic : pca with k components
kpca: -skip ${2=20}
-v - -repeat $! -l[$>]
  -repeat $2
    p={sqrt(h)}
    --l --pca -k[0,-1] -reverse -crop[0] 0,{$1-1} -transpose[0] --** -rm[1] -transpose[0] -** -endl
    -*[0] .25 -*[1] .75 -+
  -done
  -pca -crop[0] 0,0,1,{$1-1} -crop[1] 0,{$1-1}
-endl -done -v +

#@gmic denoise_klt : _number_of_components
#@gmic : denoise with karumen loeve transform
#@gmic : $ image2.jpg --noise 10 --denoise_klt -print_psnr
denoise_klt:
-v - -repeat $! -l[$>]
  -split_tiles 64,64 oW=@{0,w} oH=@{0,h} oS=@{0,s}
  -y y -a x --pca -k[0,-1] -reverse -crop[0] 0,$1
  -transpose[0] --** -rm[1] -transpose[0] -** -s x
  -resize $oW,$oH,1,$oS,-1 -append_tiles ,
-endl -done -v +


dlearn:
-split_tiles 64,64 -y y -a x -kpca 10,$1 -k[-1]

#
ddenoise:
-l[1] -split_tiles 64,64 -y y -a x -endl
-transpose[0] --** -threshold[-1] $1,1 -rm[1] -transpose[0] -** -s x -resize 8,8,1,1,-1 -append_tiles

# $ image.jpg --noise 10 --denoise_klt[1] 50% --denoise_kpca[1] 12 -print_psnr
denoise_kpca:
-v - -repeat $! -l[$>]
-parallel "
--l
-split_tiles 64,64 -y y -a x --kpca 10,$1 -k[0,-1] -reverse -transpose[0] --** -threshold[-1] $1,1 -rm[1] -transpose[0] -** -s x -resize 8,8,1,1,-1 -append_tiles ,
-endl","
--l[0]
-shift 4,4,0,0,2
-split_tiles 64,64 -y y -a x --kpca 10,$1 -k[0,-1] -reverse -transpose[0] --** -threshold[-1] $1,1 -rm[1] -transpose[0] -** -s x -resize 8,8,1,1,-1 -append_tiles ,
-shift -4,-4,0,0,2
-endl","
--l[0]
-shift 4,0,0,0,2
-split_tiles 64,64 -y y -a x --kpca 10,$1 -k[0,-1] -reverse -transpose[0] --** -threshold[-1] $1,1 -rm[1] -transpose[0] -** -s x -resize 8,8,1,1,-1 -append_tiles ,
-shift -4,0,0,0,2
-endl","
--l[0]
-shift 0,4,0,0,2
-split_tiles 64,64 -y y -a x --kpca 10,$1 -k[0,-1] -reverse -transpose[0] --** -threshold[-1] $1,1 -rm[1] -transpose[0] -** -s x -resize 8,8,1,1,-1 -append_tiles ,
-shift 0,-4,0,0,2
-endl"
-rm[0]
-+ -/ 4
-endl -done -v +

#@gmic denoise_patch_dict : _patch_size,_nb_of_shifts,_thres_comp,_thres_coef
#@gmic : Denoising using a dictionnary of patches learned on the image
#@gmic : work in progress...
#@gmic : $ image.jpg --noise 20 --denoise_patch_dict[1] , -print_psnr
denoise_patch_dict: -skip ${1=8},${2=8},${3=1.1},${4=1.1}
-e[^-1] "Denoising using a dictionnary of "$1"x"$1" patches with "$2" shifts, threshold $3x(noise std) for components and $4x(std) for coefficients."
-v - -repeat $! -l[$>]
  Sigma=@{-noise_std[0]} # measure the noise level
  # mirror to prevent side effect
  --crop 0,0,$1,100% -mirror[-1] x -reverse --crop[-1] {w-$1-1},0,100%,100% -mirror[-1] x -a x
  --crop 0,0,100%,$1 -mirror[-1] y -reverse --crop[-1] 0,{h-$1-1},100%,100% -mirror[-1] y -a y
  # resize the image to get integer nb of tiles (using mirrored version)
  oW=@{0,w} oH=@{0,h} oS=@{0,s} nW={$1*round($oW/$1,1,1)} nH={$1*round($oH/$1,1,1)}
  --crop {2*$oW-$nW},0,100%,100% -mirror[-1] x -a x
  --crop 0,{2*$oH-$nH},100%,100% -mirror[-1] y -a y
  NtileX={round($nW/$1)}  NtileY={round($nH/$1)}
  # compute a dictionnary (use several shifts)
  --l[-1]
    -repeat $2
      -if {$2>1} dx={round(?(0,$1))} dy={round(?(0,$1))} -else dx=0 dy=0 -endif
      --shift[0] $dx,$dy,0,0,2
      -split_tiles[-1] $NtileX,$NtileY pW=@{1,w} pH=@{1,h} # split the image
    -done -rm[0]
    -y y -a x n=@{-1,w} -- 'ia' --transpose[-1] -**[-2,-1] -/ $n -eigen # PCA
    # select components based on noise level
    -l[-2] -unroll x -sqrt -gt {$3*$Sigma} -f 'abs(i(x+1)-i(x))'
    T=@{-1,C} 4 -f[-1] $T T=@{-1,i(0)} -endl
    -if {$T==0} T=100% -endif -k[-1] -columns 0,$T
  -endl
  # denoise the image using the dictionnary
  -repeat $2
    -if {$2>1} dx={round(?(0,$1))} dy={round(?(0,$1))} -else dx=0 dy=0 -endif
    --shift[0] $dx,$dy,0,0,2
    -l[1,-1]
      -l[1] -split_tiles $NtileX,$NtileY -unroll y -a x -endl
      -transpose[0] --**                # project on the dictionnary
      t=@{-mad[-1]}                     # estimate variance of coefficients
      -f[-1] 'if(abs(i)<$4*$t,0,i)'     # threshold the coefficients
      -rm[1] -transpose[0] --** -rm[-2] # project back
    -endl
    -l[-1]
       -s x -resize $pW,$pH,1,$oS,-1
       -append_tiles $NtileX,$NtileY
       -shift {-$dx},{-$dy},0,0,2
     -endl
  -done
  -rm[0,1]
  -+ -/ $2
  -crop {$1+1},{$1+1},{$oW-$1-2},{$oH-$1-2}
-endl -done -v +


#@gmic iuwt: _nlevels>2,_spline>1
#@gmic : Compute the "isotropic undecimated wavelet transform" using
#@gmic : a trou algorithm for the B3-Spline wavelet.
#@gmic : The inverse is obtained as the sum of all coefficients
#@gmic : $ image.jpg -iuwt 4,1 -n 0,255 -append_tiles
#@gmic : $ image.jpg -iuwt 3,1 -+
iuwt: -skip ${1=3},${2=3}
  -e[^-1] "Compute isotropic undecimated wavelet transform"
  -v - -repeat $! -l[$<]
  # Compute the Spline filter by succesive convolutions
  50
  -l[-1]
    -f 'if(x==w/2|x==w/2-1,1,0)' -i [0]
    -repeat $2 -convolve[-1] [0] -done
    -k[-1] -autocrop 0 -/ {ia*w}
  -endl
  # Compute the decomposition
   -repeat {$1-1}
     -l[-1,-2]
      --convolve[0] [1]
      -y[1] y -convolve[-1] [1]
      ---[0] [-1] -rm[0] -reverse
     -endl
     # add trou for the next scale
     -l[-1] -y y 100% -a x -s y -s x -rm[-1] -a x -endl
    -done
    -rm[-1] -reverse
  -endl -done -v +

#@gmic iuwt_std : _nlevels>2,_spline>1
#@gmic : Compute noise at each level of the iuwt
#@gmic : $ image.jpg -iuwt_std 10,10
iuwt_std:
 -v - -repeat $! -l[$>]
 sigma=@{-noise_std}
 -f 0 -noise $sigma -iuwt $1,$2 -repeat $! -l[$>] x={sqrt(iv)} -rm 1 -f $x -endl -done -a x
  -endl -done -v +

#@gmic denoise_iuwt:_threshold>0,_nlevels>2,_spline>1
#@gmic : Denoising by thresholding the coefficients of the "isotropic undecimated wavelet transform"
#@gmic : $ image.jpg --noise 10 --denoise_iuwt[-1] , -print_psnr
denoise_iuwt: -check "${1=1.4}>0&&${2=4}>2&&${3=3}>0"
  -e[^-1] "Denoise using the isotropic undecimated B"$3" spline wavelet transform"
  -v - -repeat $! -l[$>]
    # Compute noise std at each level
    --iuwt_std[0] $2,$3 -reverse
    # comupte the wavelet coefficient and threshold them
    -iuwt[-1] $2,$3 -repeat {$!-2} -threshold[{$>+2}] {$1*@{0,i($>)}},1 -done
    # reconstruct
    -+[1--1]
    -rm[0]
  -endl -done  -v +

#---------------------------------
#
#@gmic :: Segmentation
#
#---------------------------------

#@gmic contour2d: _tolerance
#@gmic : Draw a 2D contour of regions with tolerance _tolerance
#@gmic : Default value _tolerance=.1
#@gmic : $ image.jpg -norm -blur 1 -gt 50% --contour2d
contour2d: -skip ${1=.1}
-v - -repeat $! -l[$>]
-f 'if(abs(i(x,y)-i(x+1,y+1))>$1||abs(i(x,y)-i(x+1,y))>$1,1,0)'
-endl -done -v +

#@gmic segment_snake : _nb_iter,_time_step,_lambda,_threshold,_smoothness
#@gmic : Segment an image using an adaptation of Chan and Vese's method.
#@gmic : Default values _nb_iter=10,_time_step=1,_smoothness=100,_threshold=50%
#@gmic : Reference Chan and L. Vese,Active contours without edges, IEEE transactions on image processing 10(2) (2001), pp. 266-277
#@gmic : $ 256,128 -text "GMIC",40,10,100,1,255 -blur 1 -noise 20 --segment_snake , -contour2d[-1] , -resize[-1] 100%,100%,1,3,0 -n 0,255 -blend add
segment_snake: -skip ${1=10},${2=1},${3=100},${4=1},${5=1},${6=1}
-e[^-1] "Segment the image using active contours without edges using $1 iterations and time step $2, smoothness $3 and initialize with threshold of $4."
-v - -repeat $! -l[$>]
  -luminance
  --blur $5 -gt[-1] {ia+$4*sqrt(iv)}                                # initialization
  -l[-1] --distance 0 -negative[0] -distance[0] 0 -*[0] -1 -+ -endl # levelset
  -repeat $1
    # compute mean and variance of the two regions (original version is with mean only)
    # the molified step function is given by a blur of the sharp step function
    --lt[-1] 0 -blur[-1] 1 --*[0,-1] swx=@{-1,ia} sw=@{-2,ia} M1={$swx/$sw}
    -sqr[-1] swx2=@{-1,ia}  S1={max(1e-3,$swx2/$sw^2-$M1^2)} -rm[-1,-2]
    --gt[-1] 0 -blur[-1] 1 --*[0,-1] swx=@{-1,ia} sw=@{-2,ia} M2={$swx/$sw}
    -sqr[-1] swx2=@{-1,ia}  S2={max(1e-3,$swx2/$sw^2-$M2^2)} -rm[-1,-2]
    --iee[-1]                                                     # regularization
    --f[0] '(1.0/$3)*(((i(x,y)-$M1)^2)/$S1-((i(x,y)-$M2)^2)/$S2)' # data term
    -+[-2,-1]
    -*[-1] {$2/(0.0001+max(abs(@{-1,m}),abs(@{-1,M})))}           # adaptive time step
    -+[-2,-1]
    -if {$6==1} # if display
    --l  -gt[1] 0 -contour2d[1] , -n 0,1 -a c -text $>,0,0,13,1,{iM} -w -wait 10  -rm -endl
    -endif
  -done
#  -echo_stdout "("$M1","{sqrt($S1)}");("$M2", "{sqrt($S2)}")"
  -blur[-1] 1 -gt[-1] 0 -rm[0]
-endl -done -v +

#@gmic segment_cells:
#@gmic : Cell segmentation using watershed
#@gmic : $ 256,256 -noise .05,2 -blur 10,1,1 -min 80% -noise 5% --segment_cells 2,10% -contour2d[-1] , -resize[-1] 100%,100%,1,3,0 -n 0,255 -blend add
segment_cells: -skip ${1=5},${2=10%}
-blur $1
--l[0]
 --max_patch , -gt[0] $2 -* --distance 1 -mul[-1] -1 -label[-2] 0
 -watershed[-2] [-1] -rm[1]
-endl
-gt[0] $2
-*

#---------------------------------
#
#@gmic :: Patterns
#
#---------------------------------

_challenge:
108,86,1,3 -l[-1] -fractional_brownian_motion .25  -n 0,128 --norm -gt[-1] 60% -* -resize 1080,860,1,3,1  --l[-1] -blur 10 -shift[-1] 10,10 -endl -max -crop 10,10,100%,100% -negative -endl -n 0,255

#@gmic periodic_dots : _nb_angles,_scale,_start_angle
#@gmic : Generate a peridic dot pattern with 'nb angles', 'scale' and 'start angle'.
#@gmic : Default values 'nb angle=6', 'scale=4' and 'start_angle=0'
#@gmic : $ 64,64 -periodic_dots 3,6,.1 -repeat 34 -i [0]  -done   -append_tiles
periodic_dots : -skip ${1=6},${2=4},${3=.5}
-e[^-1] "Generate a periodic dot pattern with "$1" angles, scale "$2", and orientation "$3"."
-v - -repeat $! -l[$>]
 -s c -repeat $! -l[$>]
 --resize {max(w,h)},{max(w,h)},100%,100%,0
 -l[-1]
 -f 0
 -repeat $1
   -circle {w*(.5+.5/$2*cos(2*pi*($>+$3/180*pi)/$1))},{w*(.5+.5/$2*sin(2*pi*($>+$3/180*pi)/$1))},0,1,255
 -done
 -fft -a c -norm -fftshift -n 0,255
 -endl
 -resize[-1] [0],0
 -k[-1]
 -endl -done -a c
-endl -done -v +

#@gmic rays : _center_x,_center_y,_scale,_phase
#@gmic : Generate rays patterns
#@gmic : $ image.jpg --rays 155,127,10,10 -n[-1] 0,1 -mul
rays :
-e[^-1] "Generate a ray pattern centered in ($1,$2)"
-f 't=atan2(y-$2,x-$1);sin($3*t+$4)'

#@gmic fractional_brownian_motion : 0<=_hurst_index<=1,_epsilon>0
#@gmic : Generate fractional brownian motion nd signal
#@gmic : Using a power low of the form (eps+|f|)^(-2^H-1)
#@gmic : where f is the module of the frequency, H the husrt index and eps _epsilon.
#@gmic : (see also -clouds)
#@gmic : $ 400,300 -fractional_brownian_motion
fractional_brownian_motion : -skip ${1=.5},${2=1} -check "$1>=0&&$1<=1" -check "$2>0"
-v - -repeat $! -l[$>]
-f 0 -noise 1
-fft -fftshift
-if {@{0,d}==1}
-f 'rx=x-w/2;ry=y-h/2;i*($2+sqrt(rx*rx+ry*ry))^(-2*$1-1)'
-else
-f 'rx=x-w/2;ry=y-h/2;rz=z-d/2;i*($2+sqrt(rx*rx+ry*ry+rz*rz))^(-2*$1-1)'
-endif
-fftshift -ifft
-k[0]
-endl -done -v +

#@gmic clouds : _density_of_blue_sky>0,_amplitude,0<=_hurst_index<=1,_epsilon>0
#@gmic : Generate clouds on the image (see also 'frational_brownian_motion')
#@gmic : $ 64,64 -repeat 3 --clouds {10+20*$>}% -done -rm[0]
clouds : -skip ${1=50%},${2=1},${3=.5},${4=1}
-v - -repeat $! -l[$>]
-channels 0
-fractional_brownian_motion $3,$4 -negative -min $1 -negative -resize 100%,100%,1,4
-n 0,255 -s c -n[0-2] 190,255  -n[3] 0,255 -a c
-endl -done -v +

#@gmic clearbluesky:
#@gmic : Generate a Clear Blue Sky
#@gmic : $ 400,300,1,3 -clearbluesky --clouds 50% -blend alpha
clearbluesky :
-v - -repeat $! -l[$>]
1,2,1,3 -f[-1] '63,70,120,144,190,215' -resize[-1] [0],5 -k[-1]
-endl -done -v +

#---------------------------------
#
#@gmic ::  Colors
#
#---------------------------------
#@gmic wavelength_color: _wavelength
#@gmic : Convert a wavelength [380,780] to RGB color
#@gmic : from http://scienceprimer.com
#@gmic : $ image.jpg -luminance -wavelength_color 504
wavelength_color:
-v -
-if {$1>=380&$1<440}
  R={-1*($1-440)/(440-380)}
  G=0
  B=1
-elif {$1>=440&$1<490}
  R=0
  G={($1-440)/(490-440)}
  B=1
-elif {$1>=490&$1<510}
  R=0
  G=1
  B={-1*($1-510)/(510-490)}
-elif {$1>=510&$1<580}
  R={($1-510)/(580-510)}
  G=1
  B=0
-elif {$1>=580&$1<645}
  R=1
  G={-1*($1-645)/(645-580)}
  B=0
-elif {$1>=645&$1<780}
  R=1
  G=0
  B=0
-else
  R=0
  G=0
  B=0
-endif
-repeat $! -l[$>]
-mix_channels ($R;$G;$B)
-endl -done

#---------------------------------
#
#@gmic ::  GIMP
#
#---------------------------------
#@gimp _<b>Details</b>

#@gimp Sharpen [Whiten] : jeje_whiten_frequency, jeje_whiten_frequency_preview
#@gimp : Alpha = float(50,0,100)
#@gimp : Cut = bool(false)
#@gimp : sep = separator(), Preview type = choice("Full","Forward horizontal","Forward vertical","Backward horizontal","Backward vertical")
#@gimp : sep = separator(), note = note(<b>Note:</b>This filter equalizes frequencies in the image.)
#@gimp : sep = separator(), note = note("<small>Author : <i>J&#233;r&#244;me Boulanger</i>.      Latest update: <i>2013/06/01</i>.</small>")
jeje_whiten_frequency :
  -whiten_frequency {exp($1/100)-1}
  -if $2 -c 0,255 -n 0,255 -else -n 0,255 -endif

jeje_whiten_frequency_preview :
  -gimp_split_preview "-jeje_whiten_frequency $1,$2",$-1

#@gimp _<b>Repair</b>
#@gimp Smooth [Block PCA]: jeje_denoise_patch_dict, jeje_denoise_patch_dict_preview
#@gimp : Patch = choice(1,4,8,16,32)
#@gimp : Cycles = int(8,1,32)
#@gimp : Components = float(1.1,1,9)
#@gimp : Coefficients = float(1.1,0,9)
#@gimp : Remix = float(0,0,1)
#@gimp : sep = separator(), Preview type = choice("Full","Forward horizontal","Forward vertical","Backward horizontal","Backward vertical")
#@gimp : sep = separator(), note = note(<b>Note:</b>This filter is quite time consuming.)
#@gimp : sep = separator(), note = note("<small>Author : <i>J&#233;r&#244;me Boulanger</i>.      Latest update: <i>2013/03/29</i>.</small>")
jeje_denoise_patch_dict:
  --denoise_patch_dict {2^($1+2)},$2,$3,$4
  -*[0] $5 -*[1] {1-$5} -+ -c 0,255

jeje_denoise_patch_dict_preview:
  -gimp_split_preview "-jeje_denoise_patch_dict $*",$-1

#@gimp Smooth [Wiener] : jeje_local_wiener, jeje_local_wiener_preview
#@gimp : Scale = float(2,.5,10)
#@gimp : sep = separator(), Preview type = choice("Full","Forward horizontal","Forward vertical","Backward horizontal","Backward vertical")
#@gimp : sep = separator(), note = note("<small>Author : <i>J&#233;r&#244;me Boulanger</i>. Latest update: <i>2013/06/07</i>.</small>")
jeje_local_wiener :
-local_wiener $1 -c 0,255

jeje_local_wiener_preview:
-gimp_split_preview "-jeje_local_wiener $1",$-1

#@gimp Smooth [IUWT] : jeje_denoise_iuwt,jeje_denoise_iuwt_preview
#@gimp : Threshold = float(3,0,10)
#@gimp : Number of scales = int(4,2,6)
#@gimp : Wavelet = choice(2,"Spline B1","Spline B2","Spline B3","Spline B4","Spline B5","Spline B6")
#@gimp : sep = separator(), Preview type = choice("Full","Forward horizontal","Forward vertical","Backward horizontal","Backward vertical")
#@gimp : sep = separator(), note = note("<small><b>Note:</b>Denoise the image by thresholding the coefficient of the Isotropic Undecimated Wavelet Transform.</small>")
#@gimp : sep = separator(), note = note("<small>Author : <i>J&#233;r&#244;me Boulanger</i>. Latest update: <i>2013/17/12</i>.</small>")
jeje_denoise_iuwt :
-denoise_iuwt $1,$2,{$3+1}

jeje_denoise_iuwt_preview:
-gimp_split_preview "-jeje_denoise_iuwt $1,$2,$3",$-1

#@gimp Unstrip : jeje_unstrip, jeje_unstrip_preview
#@gimp : Smoothness = float(1,0,10)
#@gimp : Size = float(20,1,50)
#@gimp : Sensitivity = float(4,1,10)
#@gimp : Normalize = bool(true)
#@gimp : FFT preview = bool(false)
#@gimp : sep = separator(), Preview type = choice("Full","Forward horizontal","Forward vertical","Backward horizontal","Backward vertical")
#@gimp : sep = separator(), note = note("<small>Author : <i>J&#233;r&#244;me Boulanger</i>. Latest update: <i>2013/06/10</i>.</small>")
jeje_unstrip :
  -unstrip $1,$2,$3
  -if $5 -tape -powerspectrum -else
  -if -$4 -n 0,255 -else -c 0,255 -endif
  -endif

jeje_unstrip_preview :
  -gimp_split_preview "-jeje_unstrip $1,$2,$3,$4,$5",$-1

#@gimp Repair scanned document: jeje_scandoc, jeje_scandoc_preview(0)
#@gimp : note = note(Use filter is useful to post process document you scan with a digital camera. It peforms smoothing, background correction and white balance adjustement)
#@gimp : Smoothness = int(3,1,7)
#@gimp : Background = float(1,10,100)
#@gimp : White level = float(90,0,100)
#@gimp : Black level = float(5,0,100)
#@gimp : sep = separator(), Preview type = choice("Full","Forward horizontal","Forward vertical","Backward horizontal","Backward vertical")
#@gimp : sep = separator(), note = note("<small>Author : <i>J&#233;r&#244;me Boulanger</i>. Latest update: <i>2013/11/03</i>.</small>")
jeje_scandoc :
  -scandoc $1,$2%,$3%,$4%

jeje_scandoc_preview :
  -gimp_split_preview "-jeje_scandoc $1,$2,$3,$4",$-1

#@gimp _<b>Patterns</b>
#@gimp Periodic dots: jeje_periodic_dots, jeje_periodic_dots_preview
#@gimp : Number = int(6,2,32)
#@gimp : Scale = float(4,1,12)
#@gimp : Angle = float(0,0,360)
#@gimp : Repeat = int(1,1,10)
#@gimp : Map = choice(None,default,HSV,lines,hot,cool,jet,flag,cube)
#@gimp : sep = separator(), note = note("<small>Author : <i>J&#233;r&#244;me Boulanger</i>. Latest update: <i>2013/05/29</i>.</small>")
jeje_periodic_dots:
  tW={max(w,h)/$4}
  $tW,$tW
  -periodic_dots[-1] $*
  -repeat {$4*$4-1}
   -i [-1]
  -done
  -append_tiles[1--1] $4,$4 -k[-1]
  -if {$5>0} -n 0,255 -map {$5-1} -endif

jeje_periodic_dots_preview:
  -jeje_periodic_dots $*

#@gimp Clouds : jeje_clouds, jeje_clouds_preview
#@gimp : Density = float(50,0,100)
#@gimp : Smoothness = float(.5,0,1)
#@gimp : sep = separator(), note = note("<small>Author : <i>J&#233;r&#244;me Boulanger</i>. Latest update: <i>2013/05/29</i>.</small>")
jeje_clouds :
 --clouds $1%,1,$2 -blend alpha

jeje_clouds_preview :
 -jeje_clouds $1,$2

#@gimp Strip : jeje_strip, jeje_strip_preview
#@gimp : Angle = float(45,0,90)
#@gimp : Frequency = float(50,0,100)
#@gimp : Phase =  float(0,0,180)
#@gimp : Amplitude = float(1,0,2)
#@gimp : sep = separator(), Preview type = choice("Full","Forward horizontal","Forward vertical","Backward horizontal","Backward vertical")
#@gimp : sep = separator(), note = note("<small>Author : <i>J&#233;r&#244;me Boulanger</i>. Latest update: <i>2013/06/07</i>.</small>")
jeje_strip :
  theta={pi*$1/180}
  -f '0.5*i*(1+$4*sin(2*pi*$2*(cos($theta)*x/w+sin($theta)*y/h)+2*pi*$3/180))'
  -c 0,255

jeje_strip_preview :
  -gimp_split_preview "-jeje_strip $*",$-1

#@gimp Rays : jeje_rays, jeje_rays_preview
#@gimp : X center = float(50,0,100)
#@gimp : Y center = float(50,0,100)
#@gimp : Frequency = float(10,0,100)
#@gimp : Angle = float(0,0,360)
#@gimp : Proportion = float(0.5,0,1)
#@gimp : Color 1 = color(255,0,0)
#@gimp : Color 2 = color(255,255,0)
#@gimp : sep = separator(), Preview type = choice("Full","Forward horizontal","Forward vertical","Backward horizontal","Backward vertical")
#@gimp : sep = separator(), note = note("<small>Author : <i>J&#233;r&#244;me Boulanger</i>. Latest update: <i>2013/10/29</i>.</small>")
jeje_rays :
-s c
-l[0] -rays {w*$1/100},{h*$2/100},$3,$4 -n 0,1 -gt $5 -n $6,$9 -endl
-l[1] -rays {w*$1/100},{h*$2/100},$3,$4 -n 0,1 -gt $5 -n $7,$10 -endl
-l[2] -rays {w*$1/100},{h*$2/100},$3,$4 -n 0,1 -gt $5 -n $8,$11 -endl
-a c

jeje_rays_preview:
-gimp_split_preview "-jeje_rays $1,$2,$3,$4,$5,$6,$7,$8,$9,$10,$11",$-1

#@gimp _<b>Details</b>
#@gimp Local variance normalization : jeje_normalize_local_variance, jeje_normalize_local_variance_preview
#@gimp : Amplitude = float(50,0,100)
#@gimp : Smoothness = float(5,0,20)
#@gimp : Threshold = float(5,0,100)
#@gimp : Repeat = int (1,1,4)
#@gimp : Channel(s) = choice(3,"All","RGBA","RGB","Luminance","Blue/red chrominances","Blue chrominance","Red chrominance","Lightness","ab-components","a-component","b-component","Hue","Saturation","Value","Key","Alpha","ch-components","c-component","h-component","Red","Green","Blue","Alpha")
#@gimp : sep = separator(), Preview type = choice("Full","Forward horizontal","Forward vertical","Backward horizontal","Backward vertical")
#@gimp : sep = separator(), note = note("<small>Author : <i>J&#233;r&#244;me Boulanger</i>. Latest update: <i>2013/10/30</i>.</small>")
jeje_normalize_local_variance :
  -apply_channels "-normalize_local_variance $1,$2,$3,$4",$5,0
  -c 0,255

jeje_normalize_local_variance_preview:
  -gimp_split_preview "-jeje_normalize_local_variance $1,$2,$3,$4,$5",$-1

#@gimp Spotify : jeje_spotify,jeje_spotify_preview
#@gimp : Scale = float(1,0.75,10)
#@gimp : Iteration = int(1,0,10)
#@gimp : Cut = bool(1)
#@gimp : Channel(s) = choice(3,"All","RGBA","RGB","Luminance","Blue/red chrominances","Blue chrominance","Red chrominance","Lightness","ab-components","a-component","b-component","Hue","Saturation","Value","Key","Alpha","ch-components","c-component","h-component","Red","Green","Blue","Alpha")
#@gimp : sep = separator(), Preview type = choice("Full","Forward horizontal","Forward vertical","Backward horizontal","Backward vertical")
#@gimp : sep = separator(), note = note("<small>Author : <i>J&#233;r&#244;me Boulanger</i>. Latest update: <i>2013/12/16/i>.</small>")
jeje_spotify:
 -apply_channels "-spotify $1,$2 -if $3 -c 0,255 -else -n 0,255 -endif",$4,0

jeje_spotify_preview:
  -gimp_split_preview "-jeje_spotify $1,$2,$3,$4",$5

#@gimp _<b>Testing</b>
#@gimp <i>J&#233;J&#233;</i>
#@gimp 3D Rendering: jeje_render3d, jeje_render3d_preview
#@gimp : Input image = file()
#@gimp : Size = int(8,4,16)
#@gimp : Quality = int(6,2,16)
#@gimp : Opacity = float(0.1,0,1)
#@gimp : Angle X = float(240,0,360)
#@gimp : Angle Y = float(0,0,360)
#@gimp : Angle Z = float(30,0,360)
#@gimp : Zoom = float(1,0,3)
#@gimp : Top color = color(32,32,64,255)
#@gimp : Bottom Color = color(64,128,96,255)
#@gimp : Render = bool(false)
#@gimp : sep = separator(), note = note(<b>Note:</b>Adjust the 3D view first and then enable render to compute the volume rendering.)
#@gimp : sep = separator(), note = note("<small>Author : <i>J&#233;r&#244;me Boulanger</i>. Latest update: <i>2013/05/29</i>.</small>")
jeje_render3d:
  W=@{0,w}
  1,2,1,4 -f[-1] $9,$13,$10,$14,$11,$15,$12,$16 -resize[-1] @{0,w},@{0,h},1,4,5
  -blend alpha
  -i $1 -a[1--1] z
  -l[-1]
  -if $17 -displayvolume $2,$3,$4 -else  -boundingbox3d 20 -endif
  -rotate3d 0,0,1,$7
  -rotate3d 0,1,0,$6
  -rotate3d 1,0,0,$5
  -c3d -n3d -*3d {3*$W*$8/4}
  -endl
  -object3d[0] [1],50%,50%,0,1
  -n 0,255
  -rm[1]

jeje_render3d_preview:
    -jeje_render3d $*


#@gimp Deconvolve: jeje_deconvolve, jeje_deconvolve_preview
#@gimp : Iterations = int(20,1,100)
#@gimp : Algorithm = choice(0,"Richardson-Lucy","Gold-Meinel")
#@gimp : Channel(s) = choice(3,"All","RGBA","RGB","Luminance","Blue/red chrominances","Blue chrominance","Red chrominance","Lightness","ab-components","a-component","b-component","Hue","Saturation","Value","Key","Alpha","ch-components","c-component","h-component","Red","Green","Blue","Alpha")
#@gimp : sep = separator(), Preview type = choice("Full","Forward horizontal","Forward vertical","Backward horizontal","Backward vertical")
#@gimp : sep = separator(), note = note("<small>Author : <i>J&#233;r&#244;me Boulanger</i>. Latest update: <i>2014/01/27</i>.</small>")
jeje_deconvolve:
-reverse
-if {$2==1}
  -apply_channels "-deconvolve_goldmeinel $1 -n[0] 0,255",$3,0
-else
  -apply_channels "-deconvolve_richardsonlucy $1 -n[0] 0,255",$3,0
-endif

jeje_deconvolve_preview:
 -gimp_split_preview "-jeje_deconvolve $1,$2,$3",$4



# Local Variables:
# mode: sh
# time-stamp-pattern: "Lastest update: <i>%02y/%02m/%02d</i>"
# End:
#
# (End of G'MIC custom commands)
